
module ROM #(T, int DEPTH, T[DEPTH] DATA) {
    action read : int #(FROM: 0, TO: DEPTH) index'0 -> T output_data'0 {
        output_data = DATA[index]
    }
}

module RAM #(T, int DEPTH) {
	domain clk

    state T[DEPTH] mem

    domain w_dom
	action write'0 : int#(FROM: 0, TO: DEPTH) addr'0, T data'0 {
		mem[addr] = data
	}

    domain r_dom
	action read'0: int#(FROM: 0, TO: DEPTH) read_addr'0 -> T read_data'0 {
		read_data = mem[read_addr]
	}
}

module FIFO #(T, int DEPTH, int MAY_PUSH_LATENCY) {
	RAM#(T, DEPTH) mem
	state int#(FROM: 0, TO: DEPTH) read_addr
	state int#(FROM: 0, TO: DEPTH) write_addr

    domain clk
    action rst'0 {
        write_addr = 0
        read_addr = 0
    }

	int space_remaining = read_addr - (write_addr + 1) mod DEPTH

    domain write
    output bool may_push'-MAY_PUSH_LATENCY = LatencyOffset #(OFFSET: -MAY_PUSH_LATENCY)(space_remaining > MAY_PUSH_LATENCY)
    action push'0 : T push_data'0 {
        mem.write(write_addr, push_data)
        write_addr = write_addr + 1 mod DEPTH
    }
    
    domain read
    output bool may_pop'0 = read_addr != write_addr
    action pop'0 : -> T pop_data'0 {
        pop_data = mem.read(read_addr)
        read_addr = read_addr + 1 mod DEPTH
    }
}

/// A FIFO implemented as a sequence of registers with a accompanying valid bit. 
///
/// Bandwidth limited to 1 element every 2 cycles.  
///
/// Use for very small FIFOs, in bandwidth-limited circumstances. 
module RippleFIFO#(T, int DEPTH) {
	state T[DEPTH] datas
	state bool[DEPTH] valids

	for int I in 0..DEPTH - 1 {
		when !valids[I+1] & valids[I] {
			datas[I+1] = datas[I]
			valids[I+1] = true
			valids[I] = false
		}
	}

	domain push_dom
	output bool may_push'0 = !valids[0]
	action push'0: T push_data'0 {
		datas[0] = push_data
		valids[0] = true
	}

	domain pop_dom
	output bool may_pop'0 = valids[DEPTH-1]
	action try_pop'0 : -> bool did_pop'0, T pop_data'0 {
		pop_data = datas[DEPTH-1]
		valids[DEPTH-1] = false
	}
}
