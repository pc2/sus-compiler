
module Iterator #(int MAX) {
	state int #(FROM: 0, TO: MAX + 2) current_limit
	state int #(FROM: 0, TO: MAX + 1) value_state
	output state bool may_next'0
	initial current_limit = 0
	initial value_state = 0
	initial may_next = false

	/// Requires `!may_next`
	action start'0 : int #(FROM: 0, TO: MAX + 2) up_to'0 {
		current_limit = up_to
		value_state = 0
		may_next = true
	}

	/// Requires `may_next`
	action next'0 : -> int #(FROM: 0, TO: MAX + 1) value'0, bool last'0 {
		last = value_state == current_limit
		value = value_state
		when !last {
			value_state = unsafe_int_cast#(FROM: 0, TO: MAX + 1)(value_state + 1)
		} else {
			may_next = false
		}
	}
}

module FixedSizeIterator #(int TO) {
	state int #(FROM: 0, TO) value_state
	output state bool may_next'0
	initial value_state = 0
	initial may_next = false

	/// Requires `!may_next`
	action start'0 {
		value_state = 0
		may_next = true
	}
	/// Requires `may_next`
	action next'0 : -> int #(FROM: 0, TO) value'0, bool last'0 {
		last = value_state == TO - 1
		value = value_state
		when !last {
			value_state = unsafe_int_cast#(FROM: 0, TO)(value_state + 1)
		} else {
			may_next = false
		}
	}
}



/// Allows us to update a blob of state with a pipelined update function
/// update() may only be called if may_update, upon which may_update goes low for UPDATE_PIPELINE_DEPTH cycles
module SlowState #(T, T RESET_TO, int OLD_DELAY, int NEW_DELAY) {
    assert#(C: OLD_DELAY >= 0)
    gen int UPDATE_TOTAL_DEPTH = max#(A: OLD_DELAY, B: OLD_DELAY + NEW_DELAY)
    domain clk
    input bool rst
    CrossDomain cross_rst
    cross_rst.in = rst

    domain data
    output state T old'-OLD_DELAY

    T new_s'NEW_DELAY
    bool update_s'0

    bool update_old'-OLD_DELAY = LatencyOffset#(OFFSET: -UPDATE_TOTAL_DEPTH)(update_s) // Despite their differing absolute latency, they of course need to be set back by the same amount, potentially introducing a pipeline stage
    T new_old'-OLD_DELAY = LatencyOffset#(OFFSET: -UPDATE_TOTAL_DEPTH)(new_s)
    when cross_rst.out {
        old = RESET_TO
    } else when update_old {
        old = new_old
    }

    output bool may_update'0
    action update'0 : T new'NEW_DELAY {
        update_s = true
        new_s = new
    } else {
        update_s = false
    }

    if UPDATE_TOTAL_DEPTH != 0 {
        state bool[UPDATE_TOTAL_DEPTH] cooldown
        may_update = cooldown[0]
        when update_s | cross_rst.out { // Importantly, there are no pipeline registers on update for the cooldown. Otherwise it could be called twice rapidly in a row
            cooldown = Repeat(false)
        } else {
            cooldown[0:UPDATE_TOTAL_DEPTH - 1] = cooldown[1:]
            cooldown[UPDATE_TOTAL_DEPTH - 1] = true
        }
    } else {
        may_update = true
    }
}

