
module JoinDomains #(T1, T2, int OFFSET) {
	interface identity1 : T1 i1'0 -> T1 o1'0
	interface identity2 : T2 i2'OFFSET -> T2 o2'OFFSET

	o1 = i1
	o2 = i2
}

module SlowClockGenerator #(int PERIOD) {
	interface SlowClockGenerator : -> state int cur_value

	initial cur_value = 0

	when cur_value == PERIOD-1 {
		cur_value = 0
	} else {
		cur_value = cur_value + 1
	}
}

module Abs #(int TO) {
	interface Abs : int #(FROM: -TO+1, TO) a -> int #(FROM: 0, TO) o

	when a < 0 {
		o = IntNarrow#(FROM: 0, TO)(-a)
	} else {
		o = IntNarrow#(FROM: 0, TO)(a)
	}
}

/// Returns an array of SIZE copies of v - should not consume any hardware
/// Runtime version of [RepeatGen]
module Repeat #(T, int SIZE) {
	interface Repeat : T v'0 -> T[SIZE] result'0

	for int I in 0..SIZE {
		result[I] = v
	}
}

/// Reverse an array - should not consume any hardware
/// Runtime version of [ReverseGen]
module Reverse #(T, int SIZE) {
	interface Reverse : T[SIZE] v'0 -> T[SIZE] result'0

	for int I in 0..SIZE {
		result[I] = v[SIZE - I - 1]
	}
}

/// Concatenate two arrays, such that the elements of b come after the elements of a - should not consume any hardware
/// Runtime version of [ConcatGen]
module Concat #(T, int SIZE_A, int SIZE_B) {
	interface Concat : T[SIZE_A] a'0, T[SIZE_B] b'0 -> T[SIZE_A + SIZE_B] result'0

	result[:SIZE_A] = a
	result[SIZE_A:] = b
}

module BitSelect #(int SIZE) {
	interface BitSelect : int#(FROM: 0, TO: SIZE - 1) selection'0 -> bool[SIZE] bits'0

	for int I in 0..SIZE {
		bits[I] = false
	}

	bits[selection] = true
}

module PopCount #(int WIDTH) {
	// Should be chosen based on what's most efficient for the target architecture
	gen int BASE_CASE_SIZE = 5

	interface PopCount : bool[WIDTH] bits'0 -> int#(FROM: 0, TO: WIDTH+1) popcount

	if WIDTH == 0 {
		int zero'0 = 0
		popcount = zero
	} else if WIDTH <= BASE_CASE_SIZE {
		int[WIDTH] cvt
		for int I in 0..WIDTH {
			when bits[I] {
				cvt[I] = 1
			} else {
				cvt[I] = 0
			}
		}
		if WIDTH == 1 {
			popcount = cvt[0]
		} else if WIDTH == 2 {
			popcount = cvt[0] + cvt[1]
		} else if WIDTH == 3 {
			popcount = cvt[0] + cvt[1] + cvt[2]
		} else if WIDTH == 4 {
			popcount = cvt[0] + cvt[1] + cvt[2] + cvt[3]
		} else if WIDTH == 5 {
			popcount = cvt[0] + cvt[1] + cvt[2] + cvt[3]  + cvt[4]
		} else {
			assert#(C: false)
		}
	} else {
		reg reg popcount = PopCount(bits[:WIDTH / 2]) + PopCount(bits[WIDTH / 2:])
	}
}


// Recursive Tree Add module recurses smaller copies of itself.
module TreeAdd #(int WIDTH, int FROM, int TO) {
	interface TreeAdd : int#(FROM, TO)[WIDTH] values'0 -> int#(FROM: FROM*WIDTH, TO: (TO - 1)*WIDTH + 1) total

	if WIDTH == 0 {
		// Have to explicitly give zero a latency count.
		// Otherwise total's latency can't be determined.
		int zero'0 = 0
		total = zero
	} else if WIDTH == 1 {
		total = values[0]
	} else {
		// Or instantiate submodules inline
		int left_total = TreeAdd(values[:WIDTH / 2])
		int right_total = TreeAdd(values[WIDTH / 2:])

		// Can add pipelining registers here too.
		// Latency Counting will figure it out.
		reg total = left_total + right_total
	}
}

/// Splits the given integer. The upper [LOWER_BITS:] bits are returned as upper, the lower [:LOWER_BITS] bits are returned in lower
/// See also [BitwiseIntConcat]
module BitwiseIntSplit #(int TO, int LOWER_BITS) {
    gen int UPPER_TO = (TO-1) / pow2#(E: LOWER_BITS) + 1
    interface BitwiseIntSplit :
        int#(FROM: 0, TO) v'0 ->
        int#(FROM: 0, TO: UPPER_TO) upper'0,
        int#(FROM: 0, TO: pow2#(E: LOWER_BITS)) lower'0

    bool[clog2#(V: TO)] v_bits = UIntToBits(v)

    lower = BitsToUInt(v_bits[:LOWER_BITS])
	// we use FromBits rather than BitsToUInt, because we can then immediately adjust the range too
    upper = FromBits#(T: type int#(FROM: 0, TO: UPPER_TO))(v_bits[LOWER_BITS:])
}

/// Recombines a lower and upper integer parts.
/// See also [BitwiseIntSplit]
module BitwiseIntConcat #(int UPPER_TO, int LOWER_BITS) {
    interface BitwiseIntConcat :
        int#(FROM: 0, TO: UPPER_TO) upper'0,
        int#(FROM: 0, TO: pow2#(E: LOWER_BITS)) lower'0 ->
        int#(FROM: 0, TO: UPPER_TO * pow2#(E: LOWER_BITS)) v'0

    bool[clog2#(V: UPPER_TO) + LOWER_BITS] v_bits
    v_bits[:LOWER_BITS] = UIntToBits(lower)
    v_bits[LOWER_BITS:] = UIntToBits(upper)
	// we use FromBits rather than BitsToUInt, because we can then immediately adjust the range too
    v = FromBits#(T: type int#(FROM: 0, TO: UPPER_TO * pow2#(E: LOWER_BITS)))(v_bits)
}

/// Sets the lower [:LOWER_BITS] bits to false, thus aligning the value
/// Works for unsigned and signed integers alike
module AlignToPow2 #(int FROM, int TO, int LOWER_BITS) {
    gen int ALIGNED_FROM = FROM - (FROM mod clog2#(V: LOWER_BITS))
    gen int ALIGNED_TO = TO - (TO + 1 mod clog2#(V: LOWER_BITS))
    interface AlignToPow2 :
        int#(FROM, TO) i'0 ->
        int#(FROM: ALIGNED_FROM, TO: ALIGNED_TO) o'0

    bool[sizeof#(T: type int#(FROM, TO))] bits = ToBits(i)
    bool[sizeof#(T: type int#(FROM, TO))] aligned_bits
    aligned_bits[:LOWER_BITS] = Repeat(false)
    aligned_bits[LOWER_BITS:] = bits[LOWER_BITS:]
	// we use FromBits rather than BitsToInt, because we can then immediately adjust the range too
    o = FromBits#(T: type int#(FROM: ALIGNED_FROM, TO: ALIGNED_TO))(aligned_bits)
}

/// Converts a '0' or '1' into the equivalent boolean 'false' or 'true' respectively
module IntToBool {
    interface IntToBool : int#(FROM: 0, TO: 2) i'0 -> bool o'0

    o = i == 1
}
/// Converts a 'false' or 'true' into the equivalent integer '0' or '1' respectively
module BoolToInt {
    interface BoolToInt : bool i'0 -> int#(FROM: 0, TO: 2) o'0

    when i {
        o = 1
    } else {
        o = 0
    }
}

/// Equivalent to the C/Verilog `cond ? a : b` ternary operator. When `cond` is `true` it returns `a`, otherwise it returns `b`
module Ternary #(T) {
    interface Ternary : bool cond'0, T a'0, T b'0 -> T o'0

    when cond {
        o = a
    } else {
        o = b
    }
}

/// Rotates towards lower indexes by the provided offset. Implemented as a Barrel Shifter
///
/// Example: `RotateLeft([1, 2, 3, 4], 1) == [2, 3, 4, 1]`
module RotateLeft#(T, int ARRAY_LEN) {
    interface RotateLeft : T[ARRAY_LEN] data'0, int#(FROM: 0, TO: ARRAY_LEN) offset'0 -> T[ARRAY_LEN] rotated_data'0

    gen int NUM_STAGES = clog2#(V: ARRAY_LEN)
    bool[NUM_STAGES] offset_bits = UIntToBits(offset)

    T[ARRAY_LEN][NUM_STAGES+1] rotate_stages
    rotate_stages[0] = data

    for int STAGE in 0..NUM_STAGES {
        T[ARRAY_LEN] from = rotate_stages[STAGE]

        for int ELEM in 0..ARRAY_LEN {
            when offset_bits[STAGE] {
                rotate_stages[STAGE+1][ELEM] = from[ELEM + pow2#(E: STAGE) mod ARRAY_LEN]
            } else {
                rotate_stages[STAGE+1][ELEM] = from[ELEM]
            }
        }
    }

    rotated_data = rotate_stages[NUM_STAGES]
}

/// Rotates towards higher indexes by the provided offset. Implemented as a Barrel Shifter
///
/// Example: `RotateRight([1, 2, 3, 4], 1) == [4, 1, 2, 3]`
module RotateRight#(T, int ARRAY_LEN) {
    interface RotateRight : T[ARRAY_LEN] data'0, int#(FROM: 0, TO: ARRAY_LEN) offset'0 -> T[ARRAY_LEN] rotated_data'0

    gen int NUM_STAGES = clog2#(V: ARRAY_LEN)
    bool[NUM_STAGES] offset_bits = UIntToBits(offset)

    T[ARRAY_LEN][NUM_STAGES+1] rotate_stages
    rotate_stages[0] = data

    for int STAGE in 0..NUM_STAGES {
        T[ARRAY_LEN] from = rotate_stages[STAGE]

        for int ELEM in 0..ARRAY_LEN {
            when offset_bits[STAGE] {
                rotate_stages[STAGE+1][ELEM] = from[ELEM - pow2#(E: STAGE) mod ARRAY_LEN]
            } else {
                rotate_stages[STAGE+1][ELEM] = from[ELEM]
            }
        }
    }

    rotated_data = rotate_stages[NUM_STAGES]
}

/// Temporary module for creating and deconstructing tuples, until we have structs
module Tuple2 #(T1, T2) {
    gen int SIZE1 = sizeof#(T: type T1)
    gen int SIZE2 = sizeof#(T: type T2)
    domain clk

    domain pack_dom
    interface pack : T1 v1_i'0, T2 v2_i'0 -> bool[SIZE1 + SIZE2] packed_o'0
    packed_o[:SIZE1] = ToBits(v1_i)
    packed_o[SIZE1:] = ToBits(v2_i)

    domain unpack_dom
    interface unpack : bool[SIZE1 + SIZE2] packed_i'0 -> T1 v1_o'0, T2 v2_o'0
    v1_o = FromBits(packed_i[:SIZE1])
    v2_o = FromBits(packed_i[SIZE1:])
}

/// Temporary module for creating and deconstructing tuples, until we have structs
module Tuple3 #(T1, T2, T3) {
    gen int SIZE1 = sizeof#(T: type T1)
    gen int SIZE2 = sizeof#(T: type T2)
    gen int SIZE3 = sizeof#(T: type T3)
    domain clk

    domain pack_dom
    interface pack : T1 v1_i'0, T2 v2_i'0, T3 v3_i'0 -> bool[SIZE1 + SIZE2 + SIZE3] packed_o'0
    packed_o[:SIZE1] = ToBits(v1_i)
    packed_o[SIZE1:SIZE1+SIZE2] = ToBits(v2_i)
    packed_o[SIZE1+SIZE2:] = ToBits(v3_i)

    domain unpack_dom
    interface unpack : bool[SIZE1 + SIZE2 + SIZE3] packed_i'0 -> T1 v1_o'0, T2 v2_o'0, T3 v3_o'0
    v1_o = FromBits(packed_i[:SIZE1])
    v2_o = FromBits(packed_i[SIZE1:SIZE1+SIZE2])
    v3_o = FromBits(packed_i[SIZE1+SIZE2:])
}

/// Temporary module for creating and deconstructing tuples, until we have structs
module Tuple4 #(T1, T2, T3, T4) {
    gen int SIZE1 = sizeof#(T: type T1)
    gen int SIZE2 = sizeof#(T: type T2)
    gen int SIZE3 = sizeof#(T: type T3)
    gen int SIZE4 = sizeof#(T: type T4)
    domain clk

    domain pack_dom
    interface pack : T1 v1_i'0, T2 v2_i'0, T3 v3_i'0, T4 v4_i'0 -> bool[SIZE1 + SIZE2 + SIZE3 + SIZE4] packed_o'0
    packed_o[:SIZE1] = ToBits(v1_i)
    packed_o[SIZE1:SIZE1+SIZE2] = ToBits(v2_i)
    packed_o[SIZE1+SIZE2:SIZE1+SIZE2+SIZE3] = ToBits(v3_i)
    packed_o[SIZE1+SIZE2+SIZE3:] = ToBits(v4_i)

    domain unpack_dom
    interface unpack : bool[SIZE1 + SIZE2 + SIZE3 + SIZE4] packed_i'0 -> T1 v1_o'0, T2 v2_o'0, T3 v3_o'0, T4 v4_o'0
    v1_o = FromBits(packed_i[:SIZE1])
    v2_o = FromBits(packed_i[SIZE1:SIZE1+SIZE2])
    v3_o = FromBits(packed_i[SIZE1+SIZE2:SIZE1+SIZE2+SIZE3])
    v4_o = FromBits(packed_i[SIZE1+SIZE2+SIZE3:])
}
