
// For now these builtin declarations must be in this order, because they're constants in the code. 
// We'll get a better system for this at some point

/// The decider of truth and falsity
__builtin__ struct bool {}
// An integer of variable size.
__builtin__ struct int #(int FROM, int TO) {}

/// Single precision IEEE 32-bit float. Operators are provided by external libraries, but it's defined here for convenience. 
__builtin__ struct float {}

/// Single precision IEEE 64-bit double-precision float. Operators are provided by external libraries, but it's defined here for convenience. 
__builtin__ struct double {}

/// Gen-only type for strings. Only used to pass strings to Verilog submodules - like data files for ROMs. 
__builtin__ struct string {}

/// For intentionally triggering an ICE for debugging. It is a constant that crashes the compiler when it is evaluated
__builtin__ const bool __crash_compiler {}

/// True, as in '1'
__builtin__ const bool true {}
/// False, as in '0'
__builtin__ const bool false {}

/// Fails to execute iff `C == false`
__builtin__ const bool assert #(bool C) {}

/// Returns the size of the given type, in bits. 
///
/// `sizeof #(T: type bool) = 1`
/// `sizeof #(T: type bool[50]) = 50`
/// `sizeof #(T: type int[10][10]) = 3200`
__builtin__ const int sizeof #(T) {}


/// Computes the Log2 of a value, rounded up. 
/// 
/// Typically used to find the size in bits that the address would need to be to address into a memory of size V. 
///
/// Requires V > 0
///
/// `clog2 #(V: 15) = 4`
/// `clog2 #(V: 16) = 4`
/// `clog2 #(V: 17) = 5`
__builtin__ const int clog2 #(int V) {}

/// Computes `2^E` at compile-time
__builtin__ const int pow2 #(int E) {}

/// Computes `B^E` at compile-time
__builtin__ const int pow #(int B, int E) {}

/// Computes `N!`
__builtin__ const int factorial #(int N) {}

/// Computes `N! / (N - K)!`. for `0 <= K <= N`
__builtin__ const int falling_factorial #(int N, int K) {}

/// Computes `N! / (K! * (N - K)!)`. for `0 <= K <= N`
__builtin__ const int comb #(int N, int K) {}

/// Compute the minimum of `A` and `B`
__builtin__ const int min #(int A, int B) {}

/// Compute the maximum of `A` and `B`
__builtin__ const int max #(int A, int B) {}

/// `Result == V`, but this prevents this from being included in the inference parameters. 
__builtin__ const int noinfer #(int V) {}

/// Generative version of [Repeat]
__builtin__ const T[SIZE] RepeatGen #(T, int SIZE, T V) {}

/// Generative version of [Reverse]
__builtin__ const T[SIZE] ReverseGen #(T, int SIZE, T[SIZE] V) {}

/// Generative version of [Concat]
__builtin__ const T[SIZE_A + SIZE_B] ConcatGen #(T, int SIZE_A, int SIZE_B, T[SIZE_A] V_A, T[SIZE_B] V_B) {}

/// Unsafe builtin to circumvent the Latency Counting System. Connects `out` to `in` without adding the requisite latency
/// Or: used for negative latencies, for instance to implement Almost-Full FIFOs, stateful for loops, etc. 
__builtin__ module LatencyOffset #(T, int OFFSET) {
    interface LatencyOffset : T in'0 -> T out'OFFSET
}

/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
__builtin__ module CrossDomain #(T) {
    domain in_clk
    input T in'0
    domain out_clk
    output T out'0
}
/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
module CrossAction #(T) {
    CrossDomain #(T: type bool) cross_valid
    CrossDomain #(T) cross_data
    domain in_clk
    action in'0 : T data_in'0 {
        cross_valid.in = true
        cross_data.in = data_in
    } else {
        cross_valid.in = false
    }
    domain out_clk
    trigger out'0 : T data_out'0

    when cross_valid.out {
        out(cross_data.out)
    }
}
/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
module CrossAction2 #(T1, T2) {
    CrossDomain #(T: type bool) cross_valid
    CrossDomain #(T: type T1) cross_data1
    CrossDomain #(T: type T2) cross_data2
    domain in_clk
    action in'0 : T1 data_in1'0, T2 data_in2'0 {
        cross_valid.in = true
        cross_data1.in = data_in1
        cross_data2.in = data_in2
    } else {
        cross_valid.in = false
    }
    domain out_clk
    trigger out'0 : T1 data_out1'0, T2 data_out2'0

    when cross_valid.out {
        out(cross_data1.out, cross_data2.out)
    }
}
/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
module CrossAction3 #(T1, T2, T3) {
    CrossDomain #(T: type bool) cross_valid
    CrossDomain #(T: type T1) cross_data1
    CrossDomain #(T: type T2) cross_data2
    CrossDomain #(T: type T3) cross_data3
    domain in_clk
    action in'0 : T1 data_in1'0, T2 data_in2'0, T3 data_in3'0 {
        cross_valid.in = true
        cross_data1.in = data_in1
        cross_data2.in = data_in2
        cross_data3.in = data_in3
    } else {
        cross_valid.in = false
    }
    domain out_clk
    trigger out'0 : T1 data_out1'0, T2 data_out2'0, T3 data_out3'0

    when cross_valid.out {
        out(cross_data1.out, cross_data2.out, cross_data3.out)
    }
}
/// Unsafe builtin to connect wires from different domains. 
/// Important: Does not perform any kind of Clock Domain Crossing!
module CrossActionNoData {
    CrossDomain #(T: type bool) cross_valid
    domain in_clk
    action in'0 {
        cross_valid.in = true
    } else {
        cross_valid.in = false
    }
    domain out_clk
    trigger out'0

    when cross_valid.out {
        out()
    }
}
module LatencyOffsetAction #(T, int OFFSET, int DATA_DELAY) {
    T stored_data
    bool is_valid
    
    action in'0 : T din'DATA_DELAY {
        is_valid = true
        stored_data = din
    } else {
        is_valid = false
    }

    trigger out'OFFSET : T dout'OFFSET+DATA_DELAY

    when LatencyOffset #(OFFSET)(is_valid) {
        out(LatencyOffset #(OFFSET)(stored_data))
    }
}

module LatencyOffsetActionNoData #(int OFFSET) {
    bool is_valid
    
    action in'0 {
        is_valid = true
    } else {
        is_valid = false
    }

    trigger out'OFFSET

    when LatencyOffset #(OFFSET)(is_valid) {
        out()
    }
}


/// Convert signed int to 2s complement bits. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Requires `-pow2 #(E: NUM_BITS - 1) <= value < pow2 #(E: NUM_BITS - 1)`
///
/// Runtime equivalent of [IntToBitsGen]
__builtin__ module IntToBits #(int NUM_BITS) {
    interface IntToBits : int #(FROM: -pow2 #(E: NUM_BITS - 1), TO: pow2 #(E: NUM_BITS - 1)) value'0 -> bool[NUM_BITS] bits'0
}
/// Convert int to unsigned bits. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Requires `0 <= value < pow2 #(E: NUM_BITS)`
///
/// Runtime equivalent of [UIntToBitsGen]
__builtin__ module UIntToBits #(int NUM_BITS) {
    interface UIntToBits : int #(FROM: 0, TO: pow2 #(E: NUM_BITS)) value'0 -> bool[NUM_BITS] bits'0
}
/// Convert 2s complement bits to a signed int. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Creates an int in the range `-pow2 #(E: NUM_BITS - 1) <= value < pow2 #(E: NUM_BITS - 1)`
///
/// Runtime equivalent of [BitsToIntGen]
__builtin__ module BitsToInt #(int NUM_BITS) {
    interface BitsToInt : bool[NUM_BITS] bits'0 -> int #(FROM: -pow2 #(E: NUM_BITS - 1), TO: pow2 #(E: NUM_BITS - 1)) value'0
}
/// Convert unsigned bits to an unsigned int. (`bits[0]` is `value`'s Least Significant Bit)
///
/// Creates an int in the range `0 <= value < pow2 #(E: NUM_BITS)`
///
/// Runtime equivalent of [BitsToUIntGen]
__builtin__ module BitsToUInt #(int NUM_BITS) {
    interface BitsToUInt : bool[NUM_BITS] bits'0 -> int #(FROM: 0, TO: pow2 #(E: NUM_BITS)) value'0
}

/// Convert gen int to 2s complement bits. (`RESULT[0]` is `V`'s Least Significant Bit)
///
/// Requires `-pow2 #(E: NUM_BITS - 1) <= V < pow2 #(E: NUM_BITS - 1)`
///
/// Generative equivalent of [IntToBits]
__builtin__ const bool[NUM_BITS] IntToBitsGen #(int NUM_BITS, int V) {}
/// Convert gen int to unsigned bits. (`RESULT[0]` is `V`'s Least Significant Bit)
///
/// Requires `0 <= V < pow2 #(E: NUM_BITS)`
///
/// Generative equivalent of [UIntToBits]
__builtin__ const bool[NUM_BITS] UIntToBitsGen #(int NUM_BITS, int V) {}
/// Convert gen 2s complement bits to a gen signed int. (`BITS[0]` is `V`'s Least Significant Bit)
///
/// Creates an int in the range `-pow2 #(E: NUM_BITS - 1) <= value < pow2 #(E: NUM_BITS - 1)`
///
/// Generative equivalent of [BitsToInt]
__builtin__ const int BitsToIntGen #(int NUM_BITS, bool[NUM_BITS] BITS) {}
/// Convert gen unsigned bits to a gen unsigned int. (`BITS[0]` is `V`'s Least Significant Bit)
///
/// Creates an int in the range `0 <= value < pow2 #(E: NUM_BITS)`
///
/// Generative equivalent of [BitsToUInt]
__builtin__ const int BitsToUIntGen #(int NUM_BITS, bool[NUM_BITS] BITS) {}


/// Bitwise conversion of type T to a sizeof#(T)-bit bitset. 
__builtin__ module ToBits #(T) {
    interface ToBits : T value'0 -> bool[sizeof #(T)] bits'0
}

/// Bitwise conversion of a sizeof#(T)-bit bitset to type T. 
__builtin__ module FromBits #(T) {
    interface FromBits : bool[sizeof #(T)] bits'0 -> T value'0
}

/// Bitwise conversion of T1 into T2. 
/// sizeof#(T: type T1) == sizeof#(T: type T2)
module Transmute #(T1, T2) {
    interface Transmute : T1 a'0 -> T2 b'0

    gen int SIZE = sizeof #(T: type T1)
    
    assert #(C: SIZE == sizeof #(T: type T2))

    bool[SIZE] as_bits = ToBits#(T: type T1)(a)
    b = FromBits#(T: type T2)(as_bits)
}

/// Unsafely shrinks the bounds of an integer.
/// The result is not defined if the value lies outside the FROM:TO range.
/// For folding behavior choose the `mod` operator instead. 
__builtin__ module IntNarrow #(int FROM_I, int TO_I, int FROM, int TO) {
    interface IntNarrow : int#(FROM: FROM_I, TO: TO_I) in'0 -> int#(FROM, TO) out'0
}
